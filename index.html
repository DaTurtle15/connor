<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini GTA Style 3D Offline</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#0b0f14; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    canvas { display:block; }
    #hud{
      position:fixed; left:12px; top:12px; color:#e6eefc; font-size:14px;
      background:rgba(0,0,0,.35); padding:10px 12px; border-radius:12px; backdrop-filter: blur(8px);
      line-height:1.25; max-width: 620px; border:1px solid rgba(255,255,255,.10);
      user-select:none;
    }
    #hint{ opacity:.9; font-size:12px; color:#cbd6ea; margin-top:6px; }
    #center {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      pointer-events:none; color:#fff; font-size:16px; text-shadow:0 2px 18px rgba(0,0,0,.85);
      opacity:0; transition: opacity 0.08s linear;
      user-select:none;
    }
    #hit {
      position:fixed; left:50%; top:50%; width:22px; height:22px; transform:translate(-50%,-50%);
      pointer-events:none; opacity:0; transition: opacity 0.06s linear;
      user-select:none;
    }
    #hit:before, #hit:after {
      content:""; position:absolute; left:50%; top:50%; width:22px; height:2px; background:rgba(255,255,255,.95);
      transform:translate(-50%,-50%) rotate(45deg);
      border-radius:999px;
    }
    #hit:after { transform:translate(-50%,-50%) rotate(-45deg); }

    #minimap {
      position:fixed; right:12px; bottom:12px;
      width:190px; height:190px;
      background:rgba(0,0,0,.35);
      border-radius:14px;
      backdrop-filter: blur(8px);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      user-select:none;
    }
    #minimap canvas { width:190px; height:190px; display:block; }
    #mmHint {
      position:fixed; right:12px; bottom:206px;
      color:#cbd6ea; font-size:12px; opacity:.85;
      background:rgba(0,0,0,.25); padding:6px 10px; border-radius:12px; backdrop-filter: blur(8px);
      border:1px solid rgba(255,255,255,.10);
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="center"></div>
  <div id="hit"></div>

  <div id="mmHint">Minimap click sets waypoint</div>
  <div id="minimap"><canvas id="mm" width="190" height="190"></canvas></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
import { SSAOPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/SSAOPass.js";
import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";

const hud = document.getElementById("hud");
const center = document.getElementById("center");
const hitUI = document.getElementById("hit");
const mmCanvas = document.getElementById("mm");
const mm = mmCanvas.getContext("2d");

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rand = (a,b)=>a+Math.random()*(b-a);
const len2 = (x,z)=>Math.hypot(x,z);

const keys = new Set();
addEventListener("keydown", (e)=>{
  keys.add(e.key.toLowerCase());
  if([" ","arrowup","arrowdown","arrowleft","arrowright"].includes(e.key.toLowerCase())) e.preventDefault();
}, {passive:false});
addEventListener("keyup", (e)=>keys.delete(e.key.toLowerCase()), {passive:true});

let mouse = { x: innerWidth/2, y: innerHeight/2, down:false };
addEventListener("mousemove", e => { mouse.x = e.clientX; mouse.y = e.clientY; }, {passive:true});
addEventListener("mousedown", ()=>mouse.down=true, {passive:true});
addEventListener("mouseup", ()=>mouse.down=false, {passive:true});

const pressedOnce = new Set();
const held = new Set();
addEventListener("keydown",(e)=>{ const k=e.key.toLowerCase(); if(!held.has(k)) pressedOnce.add(k); held.add(k); }, {passive:true});
addEventListener("keyup",(e)=>held.delete(e.key.toLowerCase()), {passive:true});
const justPressed = (k)=>pressedOnce.has(k);

const FX = { vfx:true, shake:true, slowburst:true, post:true };

// Scene
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0b0f14, 90, 780);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2600);

// Post
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const ssao = new SSAOPass(scene, camera, innerWidth, innerHeight);
ssao.kernelRadius = 14;
ssao.minDistance = 0.001;
ssao.maxDistance = 0.12;
composer.addPass(ssao);
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.55, 0.35, 0.9);
composer.addPass(bloom);

// Lighting
const hemi = new THREE.HemisphereLight(0xbad5ff, 0x0b0f14, 0.32);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 5.2);
sun.position.set(160, 220, 110);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 900;
sun.shadow.camera.left = -380;
sun.shadow.camera.right = 380;
sun.shadow.camera.top = 380;
sun.shadow.camera.bottom = -380;
sun.shadow.bias = -0.00025;
scene.add(sun);

// Dark cinematic sky (no internet assets needed)
scene.background = new THREE.Color(0x0b0f14);

// Resize
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
  ssao.setSize(innerWidth, innerHeight);
  bloom.setSize(innerWidth, innerHeight);
}, {passive:true});

// Audio
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=220, dur=0.05, gain=0.05) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "square";
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g).connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}
addEventListener("pointerdown", ()=>audioCtx.resume(), {passive:true});

// World
const WORLD = {
  size: 980,
  roadStep: 60,
  blockSize: 42,
  safe: new THREE.Vector3(-360, 0, -360),
  mission: new THREE.Vector3(360, 0, 360),
  shop: new THREE.Vector3(-360, 0, 360),
};

function makeAsphaltTexture() {
  const c = document.createElement("canvas");
  c.width = 512; c.height = 512;
  const g = c.getContext("2d");
  g.fillStyle = "#141b24";
  g.fillRect(0,0,512,512);

  for (let i=0;i<22000;i++){
    const x = (Math.random()*512)|0;
    const y = (Math.random()*512)|0;
    const v = 40 + (Math.random()*70)|0;
    g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.25})`;
    g.fillRect(x,y,1,1);
  }

  g.strokeStyle = "rgba(0,0,0,0.22)";
  g.lineWidth = 1;
  for (let k=0;k<70;k++){
    g.beginPath();
    let x = Math.random()*512;
    let y = Math.random()*512;
    g.moveTo(x,y);
    for (let j=0;j<8;j++){
      x += rand(-40,40);
      y += rand(-40,40);
      g.lineTo(x,y);
    }
    g.stroke();
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(6,6);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 8;
  return tex;
}

const asphaltTex = makeAsphaltTexture();

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(WORLD.size, WORLD.size),
  new THREE.MeshStandardMaterial({
    map: asphaltTex,
    color: 0xffffff,
    roughness: 0.95,
    metalness: 0.02
  })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

function makeRoadLines() {
  const g = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.08 });
  const half = WORLD.size/2;
  for (let x = -half; x <= half; x += WORLD.roadStep) {
    const pts = [ new THREE.Vector3(x, 0.03, -half), new THREE.Vector3(x, 0.03, half) ];
    g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
  }
  for (let z = -half; z <= half; z += WORLD.roadStep) {
    const pts = [ new THREE.Vector3(-half, 0.03, z), new THREE.Vector3(half, 0.03, z) ];
    g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
  }
  scene.add(g);
}
makeRoadLines();

function makeZone(pos, color) {
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(12, 19, 56),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.25, side:THREE.DoubleSide })
  );
  ring.rotation.x = -Math.PI/2;
  ring.position.set(pos.x, 0.06, pos.z);
  scene.add(ring);

  const disc = new THREE.Mesh(
    new THREE.CylinderGeometry(19,19,0.2, 64),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.06 })
  );
  disc.position.set(pos.x, 0.02, pos.z);
  scene.add(disc);

  return { pos, r: 19 };
}
const ZSAFE = makeZone(WORLD.safe, 0x50dca0);
const ZMIS  = makeZone(WORLD.mission, 0xffbe5a);
const ZSHOP = makeZone(WORLD.shop, 0x78b4ff);
const inZone = (p,z)=>len2(p.x-z.pos.x, p.z-z.pos.z) <= z.r;

// Buildings and colliders
const buildings = [];
function makeBuildings() {
  const g = new THREE.Group();
  const half = WORLD.size/2;
  const step = WORLD.roadStep;
  const boxGeo = new THREE.BoxGeometry(1,1,1);

  for (let x = -half + step/2; x < half; x += step) {
    for (let z = -half + step/2; z < half; z += step) {
      const h = rand(14, 84);
      const sx = WORLD.blockSize + rand(-8,8);
      const sz = WORLD.blockSize + rand(-8,8);

      const windows = Math.random() < 0.45 ? 0x9ec7ff : 0xffd9a8;
      const emissiveBoost = 0.25 + Math.random()*0.85;

      const mat = new THREE.MeshStandardMaterial({
        color: 0x141a22,
        roughness: 0.88,
        metalness: 0.05,
        emissive: new THREE.Color(windows),
        emissiveIntensity: emissiveBoost * (Math.random() < 0.35 ? 0.6 : 0.15)
      });

      const b = new THREE.Mesh(boxGeo, mat);
      b.scale.set(sx, h, sz);
      b.position.set(x + rand(-7,7), h/2, z + rand(-7,7));
      b.castShadow = true;
      b.receiveShadow = true;
      g.add(b);

      buildings.push({
        minX: b.position.x - sx/2,
        maxX: b.position.x + sx/2,
        minZ: b.position.z - sz/2,
        maxZ: b.position.z + sz/2
      });
    }
  }
  scene.add(g);
}
makeBuildings();

function resolveBuildingCollisions(pos, radius) {
  for (const b of buildings) {
    const cx = clamp(pos.x, b.minX, b.maxX);
    const cz = clamp(pos.z, b.minZ, b.maxZ);
    const dx = pos.x - cx;
    const dz = pos.z - cz;
    const d = Math.hypot(dx, dz);
    if (d < radius && d > 0.0001) {
      const push = (radius - d);
      pos.x += (dx / d) * push;
      pos.z += (dz / d) * push;
    }
  }
}

// Aim raycast
const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();
function getAimPoint() {
  mouseNDC.x = (mouse.x / innerWidth) * 2 - 1;
  mouseNDC.y = -(mouse.y / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouseNDC, camera);
  const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, hit);
  return hit;
}

// VFX particles
const particles = [];
function spawnParticle(pos, v, life, kind) {
  if (!FX.vfx) return;

  let geo;
  if (kind === "smoke") geo = new THREE.SphereGeometry(0.34, 10, 10);
  else if (kind === "fire") geo = new THREE.SphereGeometry(0.22, 10, 10);
  else geo = new THREE.SphereGeometry(0.17, 10, 10);

  let color = 0xffffff;
  let op = 0.9;
  if (kind === "smoke") { color = 0xffffff; op = 0.16; }
  if (kind === "fire") { color = 0xffc38e; op = 0.55; }

  const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity: op });
  const m = new THREE.Mesh(geo, mat);
  m.position.copy(pos);
  scene.add(m);

  particles.push({ mesh:m, v:v.clone(), life, kind });
}

let shakeTime = 0;
let slowTime = 0;

function spawnExplosion(pos, power=1) {
  if (FX.vfx) {
    const count = Math.floor(110 * power);
    for (let i=0;i<count;i++){
      const v = new THREE.Vector3(rand(-1,1), rand(0.2,1.6), rand(-1,1)).normalize().multiplyScalar(rand(22, 60) * power);
      spawnParticle(pos, v, rand(0.35, 0.9), "spark");
    }
    for (let i=0;i<Math.floor(44*power);i++){
      const v = new THREE.Vector3(rand(-1,1), rand(0.35,1.3), rand(-1,1)).normalize().multiplyScalar(rand(7, 22) * power);
      spawnParticle(pos, v, rand(0.7, 1.35), "smoke");
    }
  }
  if (FX.shake) shakeTime = Math.max(shakeTime, 0.33 * power);
  if (FX.slowburst) slowTime = Math.max(slowTime, 0.18 * power);
  beep(90, 0.06, 0.07);
  beep(55, 0.08, 0.05);
}

function updateParticles(dt) {
  for (let i=particles.length-1;i>=0;i--) {
    const p = particles[i];
    p.life -= dt;

    if (p.kind !== "smoke") p.v.y -= 40 * dt;
    else p.v.y -= 8 * dt;

    p.mesh.position.addScaledVector(p.v, dt);

    if (p.kind === "smoke") {
      p.mesh.material.opacity = clamp(p.life * 0.15, 0, 0.16);
      p.mesh.scale.multiplyScalar(1 + 0.95*dt);
    } else if (p.kind === "fire") {
      p.mesh.material.opacity = clamp(p.life * 0.8, 0, 0.55);
      p.mesh.scale.multiplyScalar(1 + 0.35*dt);
    } else {
      p.mesh.material.opacity = clamp(p.life / 0.9, 0, 0.95);
    }

    if (p.life <= 0) {
      scene.remove(p.mesh);
      particles.splice(i,1);
    }
  }
}

// Entities
function makeCar(color=0xffffff) {
  const g = new THREE.Group();

  const paint = new THREE.MeshPhysicalMaterial({
    color,
    roughness: 0.22,
    metalness: 0.95,
    clearcoat: 1.0,
    clearcoatRoughness: 0.06,
    reflectivity: 0.9
  });

  const body = new THREE.Mesh(new THREE.BoxGeometry(2.7, 0.85, 4.6), paint);
  body.castShadow = true;
  body.receiveShadow = true;
  body.position.y = 0.7;
  g.add(body);

  const glass = new THREE.MeshPhysicalMaterial({
    color: 0x0a141f,
    roughness: 0.06,
    metalness: 0.0,
    transmission: 1.0,
    thickness: 0.35,
    transparent: true,
    opacity: 0.30
  });

  const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.62, 2.5), glass);
  top.position.set(0, 1.06, -0.22);
  g.add(top);

  const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.55 });
  const l1 = new THREE.Mesh(new THREE.PlaneGeometry(0.35, 0.18), lightMat);
  l1.position.set(0.9, 0.62, 2.28);
  l1.rotation.y = Math.PI;
  g.add(l1);
  const l2 = l1.clone();
  l2.position.x = -0.9;
  g.add(l2);

  scene.add(g);
  return g;
}

function makePerson(color=0xffffff) {
  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.92, metalness:0.0 });
  const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.45, 0.75, 6, 12), mat);
  torso.position.y = 1.02;
  torso.castShadow = true;
  torso.receiveShadow = true;
  g.add(torso);
  scene.add(g);
  return g;
}

function carPhysicsTick(ent, dt, input) {
  const throttle = input.throttle;
  const brake = input.brake;
  const steer = input.steer;
  const hand = input.handbrake;

  ent.speed += throttle * ent.accel * dt;
  ent.speed -= brake * ent.decel * dt;

  ent.speed *= (1 - ent.drag * dt);
  ent.speed = clamp(ent.speed, -ent.maxR, ent.maxF);

  const grip = hand ? ent.gripHand : ent.grip;
  const steerScale = (0.35 + Math.min(1, Math.abs(ent.speed) / 18));
  ent.yaw += steer * ent.turn * dt * steerScale;

  const fwd = new THREE.Vector3(Math.sin(ent.yaw), 0, Math.cos(ent.yaw));
  const right = new THREE.Vector3(Math.cos(ent.yaw), 0, -Math.sin(ent.yaw));

  const vF = ent.vel.dot(fwd);
  const vR = ent.vel.dot(right);

  const vrNew = THREE.MathUtils.lerp(vR, 0, clamp(grip * dt, 0, 1));
  const vFNew = THREE.MathUtils.lerp(vF, ent.speed, clamp(9 * dt, 0, 1));

  ent.vel.copy(fwd).multiplyScalar(vFNew).addScaledVector(right, vrNew);
  ent.pos.addScaledVector(ent.vel, dt);

  const half = WORLD.size/2 - 16;
  ent.pos.x = clamp(ent.pos.x, -half, half);
  ent.pos.z = clamp(ent.pos.z, -half, half);

  resolveBuildingCollisions(ent.pos, ent.radius);

  ent.mesh.position.set(ent.pos.x, 0, ent.pos.z);
  ent.mesh.rotation.y = ent.yaw;
}

// Player and weapons
const player = {
  mode: "car",
  hp: 100,
  armor: 0,
  cash: 250,
  wanted: 0,
  pos: WORLD.safe.clone(),
  yaw: 0,
  punchCd: 0,
  weapon: "pistol",
  reloadT: 0,
  shootCd: 0,
  recoil: 0,
  waypoint: null
};

const WEAPONS = {
  pistol: { name:"Pistol", magSize:18, rate:0.09, speed:175, damage:14, spreadBase:0.004, recoilAdd:0.25, recoilSpread:0.006, pellets:1, range:9999, rpg:false },
  shotgun:{ name:"Shotgun", magSize:8,  rate:0.75, speed:170, damage:11, spreadBase:0.018, recoilAdd:0.35, recoilSpread:0.010, pellets:8, range:75,  rpg:false },
  sniper: { name:"Sniper", magSize:5,  rate:0.95, speed:240, damage:58, spreadBase:0.0008, recoilAdd:0.45, recoilSpread:0.002, pellets:1, range:9999, rpg:false },
  rpg:    { name:"RPG",    magSize:1,  rate:1.05, speed:60,  damage:0,  spreadBase:0.003, recoilAdd:0.55, recoilSpread:0.002, pellets:1, range:9999, rpg:true }
};
let ammo = {
  pistol: { mag:18, reserve:120 },
  shotgun:{ mag:8,  reserve:40 },
  sniper: { mag:5,  reserve:20 },
  rpg:    { mag:1,  reserve:6 }
};
function currentWeapon() { return WEAPONS[player.weapon]; }
function addWanted(x){ player.wanted = clamp(player.wanted + x, 0, 5); }

const playerCar = {
  mesh: makeCar(0xffffff),
  pos: player.pos.clone(),
  vel: new THREE.Vector3(),
  yaw: 0,
  speed: 0,
  hp: 240,
  radius: 2.3,
  maxF: 40,
  maxR: 18,
  accel: 56,
  decel: 78,
  turn: 2.55,
  drag: 1.2,
  grip: 7.6,
  gripHand: 1.7,
  state: "ok"
};

const playerGuy = makePerson(0xffffff);
playerGuy.visible = false;
playerGuy.position.copy(player.pos);

function setMode(mode) {
  if (mode === player.mode) return;
  player.mode = mode;
  if (mode === "car") {
    playerGuy.visible = false;
    playerCar.mesh.visible = true;
    playerCar.pos.copy(player.pos);
    playerCar.mesh.position.set(player.pos.x, 0, player.pos.z);
  } else {
    playerCar.mesh.visible = false;
    playerGuy.visible = true;
    playerGuy.position.copy(player.pos);
    playerCar.speed = 0;
  }
}

// Traffic
const traffic = [];
function spawnTraffic(n=18) {
  for (let i=0;i<n;i++) {
    const t = {
      mesh: makeCar(0x7fb3ff),
      pos: new THREE.Vector3(rand(-420,420), 0, rand(-420,420)),
      vel: new THREE.Vector3(),
      yaw: rand(0, Math.PI*2),
      speed: 0,
      hp: 150,
      radius: 2.3,
      maxF: 31,
      maxR: 11,
      accel: 41,
      decel: 60,
      turn: 2.2,
      drag: 1.35,
      grip: 7.0,
      gripHand: 2.2,
      target: new THREE.Vector3(rand(-430,430), 0, rand(-430,430))
    };
    t.mesh.position.set(t.pos.x, 0, t.pos.z);
    traffic.push(t);
  }
}
spawnTraffic(18);

function updateTraffic(dt) {
  for (const t of traffic) {
    if (t.dead) continue;

    const dx = t.target.x - t.pos.x;
    const dz = t.target.z - t.pos.z;
    const dist = Math.hypot(dx,dz);
    if (dist < 34) t.target.set(rand(-440,440), 0, rand(-440,440));

    const desired = Math.atan2(dx, dz);
    let diff = desired - t.yaw;
    while (diff > Math.PI) diff -= Math.PI*2;
    while (diff < -Math.PI) diff += Math.PI*2;

    const steer = clamp(diff * 1.1, -1, 1);
    const throttle = dist > 95 ? 1 : 0.35;
    const brake = Math.abs(diff) > 2.1 ? 0.85 : 0;

    carPhysicsTick(t, dt, { throttle, brake, steer, handbrake: false });

    if (t.hp <= 0 && !t.dead) {
      t.dead = true;
      spawnExplosion(new THREE.Vector3(t.pos.x, 1.0, t.pos.z), 1.05);
      scene.remove(t.mesh);
    }
  }
  for (let i=traffic.length-1;i>=0;i--) if (traffic[i].dead) traffic.splice(i,1);
}

// Pedestrians
const peds = [];
function spawnPeds(n=24) {
  for (let i=0;i<n;i++) {
    const p = {
      mesh: makePerson(0xffffff),
      pos: new THREE.Vector3(rand(-430,430), 0, rand(-430,430)),
      v: new THREE.Vector3(),
      hp: 60,
      state: "wander",
      target: new THREE.Vector3(rand(-430,430), 0, rand(-430,430)),
      punchCd: rand(0.3, 1.2)
    };
    p.mesh.position.copy(p.pos);
    p.mesh.children[0].material.color.offsetHSL(rand(-0.10,0.10), rand(-0.25,0.25), rand(-0.18,0.18));
    peds.push(p);
  }
}
spawnPeds(24);

function updatePeds(dt) {
  for (const p of peds) {
    if (p.dead) continue;

    const dxP = player.pos.x - p.pos.x;
    const dzP = player.pos.z - p.pos.z;
    const dP = Math.hypot(dxP, dzP);

    if (player.wanted > 0.4 && dP < 60) p.state = "flee";
    else if (dP < 18 && player.mode === "foot" && (mouse.down || keys.has(" "))) p.state = "fight";
    else if (p.state !== "wander" && dP > 80) p.state = "wander";

    if (p.state === "wander") {
      const dx = p.target.x - p.pos.x;
      const dz = p.target.z - p.pos.z;
      const dist = Math.hypot(dx,dz);
      if (dist < 8) p.target.set(rand(-440,440), 0, rand(-440,440));
      const ux = dx / (dist || 1);
      const uz = dz / (dist || 1);
      p.v.x = p.v.x * 0.86 + ux * 5.2 * 0.24;
      p.v.z = p.v.z * 0.86 + uz * 5.2 * 0.24;
    }

    if (p.state === "flee") {
      const ux = (-dxP) / (dP || 1);
      const uz = (-dzP) / (dP || 1);
      p.v.x = p.v.x * 0.82 + ux * 11.0 * 0.32;
      p.v.z = p.v.z * 0.82 + uz * 11.0 * 0.32;
    }

    if (p.state === "fight") {
      const ux = dxP / (dP || 1);
      const uz = dzP / (dP || 1);
      p.v.x = p.v.x * 0.75 + ux * 8.2 * 0.26;
      p.v.z = p.v.z * 0.75 + uz * 8.2 * 0.26;

      p.punchCd -= dt;
      if (p.punchCd <= 0 && dP < 2.0) {
        p.punchCd = rand(0.65, 1.05);
        player.hp -= 9;
        beep(140, 0.03, 0.03);
      }
    }

    p.pos.addScaledVector(p.v, dt);

    const half = WORLD.size/2 - 16;
    p.pos.x = clamp(p.pos.x, -half, half);
    p.pos.z = clamp(p.pos.z, -half, half);
    resolveBuildingCollisions(p.pos, 1.1);

    p.mesh.position.copy(p.pos);
    p.mesh.rotation.y = Math.atan2(p.v.x, p.v.z);

    if (p.hp <= 0 && !p.dead) {
      p.dead = true;
      spawnExplosion(new THREE.Vector3(p.pos.x, 1.0, p.pos.z), 0.6);
      scene.remove(p.mesh);
      player.cash += 25;
      addWanted(0.25);
    }
  }
  for (let i=peds.length-1;i>=0;i--) if (peds[i].dead) peds.splice(i,1);
}

// Cops
const cops = [];
function desiredCops() {
  if (player.wanted < 0.2) return 0;
  return Math.floor(1 + player.wanted * 1.9);
}
function spawnCopCar() {
  const c = {
    mesh: makeCar(0xff5a5a),
    pos: new THREE.Vector3(rand(-440,440), 0, rand(-440,440)),
    vel: new THREE.Vector3(),
    yaw: rand(0, Math.PI*2),
    speed: 0,
    hp: 190,
    radius: 2.3,
    maxF: 37,
    maxR: 15,
    accel: 54,
    decel: 80,
    turn: 2.45,
    drag: 1.22,
    grip: 7.2,
    gripHand: 2.0,
    shootCd: rand(0.25, 0.7)
  };
  const ang = rand(0, Math.PI*2);
  const r = rand(140, 210);
  c.pos.set(
    clamp(player.pos.x + Math.cos(ang)*r, -WORLD.size/2+20, WORLD.size/2-20),
    0,
    clamp(player.pos.z + Math.sin(ang)*r, -WORLD.size/2+20, WORLD.size/2-20)
  );
  c.mesh.position.set(c.pos.x, 0, c.pos.z);
  cops.push(c);
}

// Bullets and rockets
const bullets = [];
const rockets = [];

function showHitmarker() {
  hitUI.style.opacity = "1";
  setTimeout(()=>hitUI.style.opacity="0", 70);
  beep(680, 0.02, 0.03);
}

function spawnBullet(from, dir, who, speed) {
  const geo = new THREE.SphereGeometry(0.15, 10, 10);
  const mat = new THREE.MeshBasicMaterial({ color: who === "player" ? 0xffffff : 0xff7878, transparent:true, opacity:0.95 });
  const m = new THREE.Mesh(geo, mat);
  m.position.copy(from);
  scene.add(m);
  bullets.push({ mesh:m, v: dir.clone().normalize().multiplyScalar(speed), life: who === "player" ? 0.95 : 1.15, who });
}

function spawnRocket(from, dir) {
  const geo = new THREE.CylinderGeometry(0.12, 0.18, 0.9, 12);
  const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness:0.5, metalness:0.25 });
  const m = new THREE.Mesh(geo, mat);
  m.rotation.x = Math.PI/2;
  m.castShadow = true;
  m.position.copy(from);
  scene.add(m);
  rockets.push({ mesh:m, v: dir.clone().normalize().multiplyScalar(WEAPONS.rpg.speed), life: 3.2 });
  beep(240, 0.06, 0.05);
}

function radialDamage(centerPos, radius, baseDmg) {
  for (const c of cops) {
    if (c.dead) continue;
    const d = len2(centerPos.x - c.pos.x, centerPos.z - c.pos.z);
    if (d < radius) c.hp -= baseDmg * (1 - d/radius);
  }
  for (const t of traffic) {
    if (t.dead) continue;
    const d = len2(centerPos.x - t.pos.x, centerPos.z - t.pos.z);
    if (d < radius) t.hp -= baseDmg * (1 - d/radius);
  }
  for (const p of peds) {
    if (p.dead) continue;
    const d = len2(centerPos.x - p.pos.x, centerPos.z - p.pos.z);
    if (d < radius) p.hp -= baseDmg * 0.8 * (1 - d/radius);
  }
  const dP = len2(centerPos.x - player.pos.x, centerPos.z - player.pos.z);
  if (dP < radius) {
    const dmg = baseDmg * 0.7 * (1 - dP/radius);
    if (player.mode === "car") playerCar.hp -= dmg;
    else player.hp -= dmg;
    if (FX.shake) shakeTime = Math.max(shakeTime, 0.35);
  }
}

function updateCops(dt) {
  const target = desiredCops();
  while (cops.length < target) spawnCopCar();
  while (cops.length > target) { const c = cops.pop(); scene.remove(c.mesh); }

  for (const c of cops) {
    const dx = player.pos.x - c.pos.x;
    const dz = player.pos.z - c.pos.z;
    const dist = Math.hypot(dx,dz) || 1;

    const desired = Math.atan2(dx, dz);
    let diff = desired - c.yaw;
    while (diff > Math.PI) diff -= Math.PI*2;
    while (diff < -Math.PI) diff += Math.PI*2;

    const steer = clamp(diff * 1.25, -1, 1);
    const throttle = dist > 26 ? 1 : 0.2;
    const brake = dist < 13 ? 0.9 : 0;

    carPhysicsTick(c, dt, { throttle, brake, steer, handbrake:false });

    if (dist < 3.2) {
      const dmg = 22 * dt;
      if (player.mode === "car") playerCar.hp -= dmg;
      else player.hp -= dmg;
    }

    c.shootCd -= dt;
    if (player.wanted > 0 && c.shootCd <= 0 && dist < 90) {
      c.shootCd = rand(0.25, 0.55);
      spawnBullet(new THREE.Vector3(c.pos.x, 1.3, c.pos.z), new THREE.Vector3(dx, 0, dz), "cop", 130);
    }

    if (c.hp <= 0 && !c.dead) {
      c.dead = true;
      spawnExplosion(new THREE.Vector3(c.pos.x, 1.0, c.pos.z), 1.15);
      radialDamage(new THREE.Vector3(c.pos.x, 0, c.pos.z), 11, 85);
      scene.remove(c.mesh);
      player.cash += 80;
      addWanted(0.35);
    }
  }
  for (let i=cops.length-1;i>=0;i--) if (cops[i].dead) cops.splice(i,1);
}

function updateBullets(dt) {
  for (let i=bullets.length-1;i>=0;i--) {
    const b = bullets[i];
    b.life -= dt;
    b.mesh.position.addScaledVector(b.v, dt);
    const p = b.mesh.position;

    if (Math.abs(p.x) > WORLD.size/2 || Math.abs(p.z) > WORLD.size/2) b.life = -1;

    for (const bb of buildings) {
      if (p.x > bb.minX && p.x < bb.maxX && p.z > bb.minZ && p.z < bb.maxZ) { b.life = -1; break; }
    }

    const w = currentWeapon();

    if (b.who === "player") {
      for (const c of cops) {
        if (c.dead) continue;
        if (len2(p.x - c.pos.x, p.z - c.pos.z) < 2.85) {
          c.hp -= w.damage;
          b.life = -1;
          addWanted(0.35);
          player.cash += 10;
          showHitmarker();
          break;
        }
      }
      for (const t of traffic) {
        if (t.dead) continue;
        if (len2(p.x - t.pos.x, p.z - t.pos.z) < 2.85) {
          t.hp -= w.damage * 0.9;
          b.life = -1;
          addWanted(0.15);
          showHitmarker();
          break;
        }
      }
      for (const ped of peds) {
        if (ped.dead) continue;
        if (len2(p.x - ped.pos.x, p.z - ped.pos.z) < 1.25) {
          ped.hp -= w.damage;
          b.life = -1;
          addWanted(0.18);
          showHitmarker();
          break;
        }
      }
    } else {
      if (len2(p.x - player.pos.x, p.z - player.pos.z) < 1.7) {
        const dmg = 14;
        if (player.armor > 0) {
          const take = Math.min(player.armor, dmg);
          player.armor -= take;
          player.hp -= (dmg - take) * 0.5;
        } else player.hp -= dmg;
        b.life = -1;
      }
      if (player.mode === "car" && len2(p.x - playerCar.pos.x, p.z - playerCar.pos.z) < 2.85) {
        playerCar.hp -= 12;
        b.life = -1;
      }
    }

    if (b.life <= 0) {
      scene.remove(b.mesh);
      bullets.splice(i,1);
    }
  }
}

function updateRockets(dt) {
  for (let i=rockets.length-1;i>=0;i--) {
    const r = rockets[i];
    r.life -= dt;
    r.mesh.position.addScaledVector(r.v, dt);
    const p = r.mesh.position;

    if (FX.vfx && Math.random() < 0.7) {
      spawnParticle(
        new THREE.Vector3(p.x, 1.12, p.z),
        new THREE.Vector3(rand(-1,1), rand(0.1,0.5), rand(-1,1)).multiplyScalar(3),
        0.95,
        "smoke"
      );
    }

    let hit = false;
    if (Math.abs(p.x) > WORLD.size/2 || Math.abs(p.z) > WORLD.size/2) hit = true;

    if (!hit) {
      for (const bb of buildings) {
        if (p.x > bb.minX && p.x < bb.maxX && p.z > bb.minZ && p.z < bb.maxZ) { hit = true; break; }
      }
    }

    if (!hit) {
      for (const c of cops) if (!c.dead && len2(p.x - c.pos.x, p.z - c.pos.z) < 2.9) { hit = true; break; }
      for (const t of traffic) if (!t.dead && len2(p.x - t.pos.x, p.z - t.pos.z) < 2.9) { hit = true; break; }
      for (const ped of peds) if (!ped.dead && len2(p.x - ped.pos.x, p.z - ped.pos.z) < 1.4) { hit = true; break; }
    }

    if (hit || r.life <= 0) {
      const boom = new THREE.Vector3(p.x, 0, p.z);
      spawnExplosion(new THREE.Vector3(p.x, 1.0, p.z), 1.6);
      radialDamage(boom, 17, 140);
      addWanted(0.55);
      scene.remove(r.mesh);
      rockets.splice(i,1);
    }
  }
}

// Missions and zones
const mission = { active:false, type:null, timer:0, goal:null, reward:0 };
function startMission() {
  mission.active = true;
  if (Math.random() < 0.5) {
    mission.type = "DELIVERY";
    mission.timer = 55;
    mission.goal = new THREE.Vector3(rand(-440,440), 0, rand(-440,440));
    mission.reward = 450;
  } else {
    mission.type = "EVADE";
    mission.timer = 40;
    mission.goal = WORLD.safe.clone();
    mission.reward = 380;
    addWanted(2);
  }
}
function updateMission(dt) {
  if (!mission.active) {
    if (inZone(player.pos, ZMIS) && justPressed("f")) startMission();
    return;
  }
  mission.timer -= dt;
  if (mission.timer <= 0) { mission.active = false; ping("Mission failed"); return; }

  if (mission.type === "DELIVERY") {
    if (len2(player.pos.x - mission.goal.x, player.pos.z - mission.goal.z) < 16) {
      player.cash += mission.reward;
      mission.active = false;
      ping("Delivery complete");
    }
  } else {
    if (len2(player.pos.x - WORLD.safe.x, player.pos.z - WORLD.safe.z) < 19 && player.wanted <= 1) {
      player.cash += mission.reward;
      mission.active = false;
      ping("Escaped");
    }
  }
}

function updateZones(dt) {
  if (inZone(player.pos, ZSAFE)) {
    player.wanted = Math.max(0, player.wanted - 0.95 * dt);
    player.hp = Math.min(100, player.hp + 10 * dt);
    playerCar.hp = Math.min(240, playerCar.hp + 12 * dt);
  }
  if (inZone(player.pos, ZSHOP) && justPressed("f")) {
    if (player.cash >= 200) {
      player.cash -= 200;
      player.hp = 100;
      player.armor = 45;
      ping("Full heal bought");
      beep(420,0.06,0.04);
    } else {
      ping("Need $200");
      beep(160,0.06,0.04);
    }
  }
}

// Waypoint
function setWaypoint(v) {
  player.waypoint = new THREE.Vector3(v.x, 0, v.z);
  ping("Waypoint set");
  beep(320, 0.04, 0.03);
}
addEventListener("keydown", (e)=>{
  if (e.key.toLowerCase() === "m") setWaypoint(getAimPoint());
}, {passive:true});

document.getElementById("minimap").addEventListener("click", (e)=>{
  const rect = mmCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  const half = WORLD.size/2;
  const wx = (x * WORLD.size) - half;
  const wz = (y * WORLD.size) - half;
  setWaypoint(new THREE.Vector3(wx, 0, wz));
}, {passive:true});

// Player update
function updatePlayer(dt) {
  if (justPressed("v")) { FX.vfx = !FX.vfx; ping("VFX " + (FX.vfx ? "on" : "off")); }
  if (justPressed("b")) { FX.shake = !FX.shake; ping("Shake " + (FX.shake ? "on" : "off")); }
  if (justPressed("n")) { FX.slowburst = !FX.slowburst; ping("Slow burst " + (FX.slowburst ? "on" : "off")); }
  if (justPressed("p")) { FX.post = !FX.post; ping("Post " + (FX.post ? "on" : "off")); }

  if (justPressed("1")) { player.weapon = "pistol"; ping("Pistol"); }
  if (justPressed("2")) { player.weapon = "shotgun"; ping("Shotgun"); }
  if (justPressed("3")) { player.weapon = "sniper"; ping("Sniper"); }
  if (justPressed("4")) { player.weapon = "rpg"; ping("RPG"); }

  if (justPressed("e")) setMode(player.mode === "car" ? "foot" : "car");

  player.punchCd = Math.max(0, player.punchCd - dt);
  if (player.mode === "foot" && justPressed("q") && player.punchCd <= 0) {
    player.punchCd = 0.45;
    let hit = false;
    for (const ped of peds) {
      if (ped.dead) continue;
      const d = len2(player.pos.x - ped.pos.x, player.pos.z - ped.pos.z);
      if (d < 2.1) {
        ped.hp -= 18;
        hit = true;
        showHitmarker();
        addWanted(0.12);
        break;
      }
    }
    if (!hit) beep(200, 0.02, 0.02);
    else beep(160, 0.03, 0.03);
  }

  if (player.mode === "car") {
    const throttle = (keys.has("w") || keys.has("arrowup")) ? 1 : 0;
    const brake = (keys.has("s") || keys.has("arrowdown")) ? 1 : 0;
    const steer = ((keys.has("a") || keys.has("arrowleft")) ? 1 : 0) + ((keys.has("d") || keys.has("arrowright")) ? -1 : 0);
    const handbrake = keys.has("shift");

    playerCar.pos.copy(player.pos);
    playerCar.yaw = player.yaw;
    carPhysicsTick(playerCar, dt, { throttle, brake, steer, handbrake });
    player.pos.copy(playerCar.pos);
    player.yaw = playerCar.yaw;
  } else {
    const speed = 17;
    let ix = 0, iz = 0;
    if (keys.has("w") || keys.has("arrowup")) iz += 1;
    if (keys.has("s") || keys.has("arrowdown")) iz -= 1;
    if (keys.has("a") || keys.has("arrowleft")) ix -= 1;
    if (keys.has("d") || keys.has("arrowright")) ix += 1;
    const d = Math.hypot(ix,iz) || 1;
    ix/=d; iz/=d;

    const aim = getAimPoint();
    const dx = aim.x - player.pos.x;
    const dz = aim.z - player.pos.z;
    player.yaw = Math.atan2(dx, dz);

    player.pos.x += ix * speed * dt;
    player.pos.z += iz * speed * dt;

    const half = WORLD.size/2 - 16;
    player.pos.x = clamp(player.pos.x, -half, half);
    player.pos.z = clamp(player.pos.z, -half, half);

    resolveBuildingCollisions(player.pos, 1.1);

    playerGuy.position.copy(player.pos);
    playerGuy.rotation.y = player.yaw;
  }
}

// Shooting and reload
function updateShooting(dt) {
  const w = currentWeapon();
  const a = ammo[player.weapon];

  if (player.reloadT > 0) {
    player.reloadT -= dt;
    if (player.reloadT <= 0) {
      const need = w.magSize - a.mag;
      const take = Math.min(need, a.reserve);
      a.mag += take;
      a.reserve -= take;
      ping("Reloaded");
      beep(260,0.03,0.03);
      beep(340,0.03,0.03);
    }
    return;
  }

  if (justPressed("r")) {
    if (a.mag < w.magSize && a.reserve > 0) {
      player.reloadT = (w.name === "Sniper") ? 1.15 : 0.9;
      ping("Reloading");
      beep(180,0.04,0.03);
    }
  }

  player.shootCd -= dt;
  player.recoil = Math.max(0, player.recoil - 7.0 * dt);

  const wantShoot = mouse.down || keys.has(" ");
  if (!wantShoot) return;
  if (player.shootCd > 0) return;
  if (a.mag <= 0) { beep(110,0.05,0.03); return; }

  player.shootCd = w.rate;
  a.mag -= 1;
  addWanted(w.rpg ? 0.25 : 0.12);

  const aim = getAimPoint();
  const from = new THREE.Vector3(player.pos.x, player.mode === "car" ? 1.35 : 1.65, player.pos.z);
  const baseDir = aim.clone().sub(from);
  baseDir.y = 0;

  const spread = w.spreadBase + player.recoil * w.recoilSpread;

  if (w.rpg) {
    spawnRocket(from, baseDir);
  } else {
    for (let i=0;i<w.pellets;i++) {
      const dir = baseDir.clone();
      dir.x += rand(-spread, spread) * 120;
      dir.z += rand(-spread, spread) * 120;
      if (w.range < 9999) dir.normalize().multiplyScalar(w.range);
      spawnBullet(from, dir, "player", w.speed);
    }
    player.recoil = Math.min(1.25, player.recoil + w.recoilAdd);
    beep(w.name === "Sniper" ? 320 : 520, 0.02, 0.025);
  }
}

// Car damage visuals
function updateCarDamageVFX(dt) {
  if (!FX.vfx) return;

  const hp = playerCar.hp;
  if (hp > 150) playerCar.state = "ok";
  else if (hp > 80) playerCar.state = "smoke";
  else if (hp > 0) playerCar.state = "fire";

  if (playerCar.state === "smoke" && Math.random() < 0.55) {
    spawnParticle(
      new THREE.Vector3(player.pos.x, 1.18, player.pos.z),
      new THREE.Vector3(rand(-1,1), rand(0.2,0.8), rand(-1,1)).multiplyScalar(4),
      1.2,
      "smoke"
    );
  }

  if (playerCar.state === "fire") {
    if (Math.random() < 0.8) {
      spawnParticle(
        new THREE.Vector3(player.pos.x + rand(-0.4,0.4), 1.06, player.pos.z + rand(-0.4,0.4)),
        new THREE.Vector3(rand(-1,1), rand(0.9,2.0), rand(-1,1)).multiplyScalar(6),
        0.38,
        "fire"
      );
    }
    if (Math.random() < 0.55) {
      spawnParticle(
        new THREE.Vector3(player.pos.x, 1.22, player.pos.z),
        new THREE.Vector3(rand(-1,1), rand(0.2,1.1), rand(-1,1)).multiplyScalar(4),
        1.0,
        "smoke"
      );
    }
  }
}

// HUD and minimap
function stars(n){
  const full = "★".repeat(Math.floor(n));
  const empty = "☆".repeat(5 - Math.floor(n));
  return full + empty;
}
function ping(text) {
  center.textContent = text;
  center.style.opacity = "1";
  setTimeout(()=>center.style.opacity="0", 650);
}
function waypointInfo() {
  if (!player.waypoint) return { txt:"No waypoint", dist:null };
  const dx = player.waypoint.x - player.pos.x;
  const dz = player.waypoint.z - player.pos.z;
  const dist = Math.hypot(dx,dz);

  const angTo = Math.atan2(dx, dz);
  let diff = angTo - player.yaw;
  while (diff > Math.PI) diff -= Math.PI*2;
  while (diff < -Math.PI) diff += Math.PI*2;

  let dir = "ahead";
  if (diff > 0.6) dir = "left";
  if (diff < -0.6) dir = "right";
  if (Math.abs(diff) > 2.2) dir = "behind";

  return { txt:`Waypoint ${dir}`, dist };
}
function drawMinimap() {
  const w = mmCanvas.width;
  const h = mmCanvas.height;
  mm.clearRect(0,0,w,h);

  mm.strokeStyle = "rgba(255,255,255,0.08)";
  mm.lineWidth = 1;
  for (let i=1;i<6;i++){
    mm.beginPath(); mm.moveTo((w/6)*i, 0); mm.lineTo((w/6)*i, h); mm.stroke();
    mm.beginPath(); mm.moveTo(0, (h/6)*i); mm.lineTo(w, (h/6)*i); mm.stroke();
  }

  const half = WORLD.size/2;
  const toMM = (x,z)=>({ x: ((x + half) / WORLD.size) * w, y: ((z + half) / WORLD.size) * h });

  const zs = [
    { v: WORLD.safe, c: "rgba(80,220,160,0.35)" },
    { v: WORLD.mission, c: "rgba(255,190,90,0.35)" },
    { v: WORLD.shop, c: "rgba(120,180,255,0.35)" },
  ];
  for (const z of zs) {
    const p = toMM(z.v.x, z.v.z);
    mm.fillStyle = z.c;
    mm.beginPath(); mm.arc(p.x, p.y, 5, 0, Math.PI*2); mm.fill();
  }

  if (player.waypoint) {
    const p = toMM(player.waypoint.x, player.waypoint.z);
    mm.fillStyle = "rgba(255,255,255,0.9)";
    mm.beginPath(); mm.arc(p.x, p.y, 4.5, 0, Math.PI*2); mm.fill();
  }

  mm.fillStyle = "rgba(255,255,255,0.20)";
  for (const p of peds) {
    const q = toMM(p.pos.x, p.pos.z);
    mm.beginPath(); mm.arc(q.x, q.y, 1.8, 0, Math.PI*2); mm.fill();
  }

  mm.fillStyle = "rgba(120,180,255,0.22)";
  for (const t of traffic) {
    const q = toMM(t.pos.x, t.pos.z);
    mm.beginPath(); mm.arc(q.x, q.y, 1.7, 0, Math.PI*2); mm.fill();
  }

  mm.fillStyle = "rgba(255,90,90,0.75)";
  for (const c of cops) {
    const q = toMM(c.pos.x, c.pos.z);
    mm.beginPath(); mm.arc(q.x, q.y, 2.2, 0, Math.PI*2); mm.fill();
  }

  const me = toMM(player.pos.x, player.pos.z);
  mm.fillStyle = "rgba(255,255,255,0.95)";
  mm.beginPath(); mm.arc(me.x, me.y, 3.2, 0, Math.PI*2); mm.fill();

  const ax = Math.sin(player.yaw), az = Math.cos(player.yaw);
  mm.strokeStyle = "rgba(255,255,255,0.75)";
  mm.lineWidth = 2;
  mm.beginPath();
  mm.moveTo(me.x, me.y);
  mm.lineTo(me.x + ax*10, me.y + az*10);
  mm.stroke();
}

function updateHUD() {
  const wpn = currentWeapon();
  const a = ammo[player.weapon];
  const mLine = mission.active ? `Mission ${mission.type}  ${mission.timer.toFixed(0)}s` : `Go to orange circle and press F`;
  const wp = waypointInfo();

  hud.innerHTML = `
    <div><b>Mini GTA Style 3D Offline</b></div>
    <div>Mode <b>${player.mode === "car" ? "in car" : "on foot"}</b></div>
    <div>HP <b>${player.hp.toFixed(0)}</b> Armor <b>${player.armor.toFixed(0)}</b> Car HP <b>${playerCar.hp.toFixed(0)}</b></div>
    <div>Cash <b>$${player.cash.toFixed(0)}</b> Wanted <b>${stars(player.wanted)}</b></div>
    <div>Weapon <b>${wpn.name}</b> Ammo <b>${a.mag}</b> | ${a.reserve} ${player.reloadT>0 ? "(reloading)" : ""}</div>
    <div>${mLine}</div>
    <div>${wp.dist === null ? wp.txt : `${wp.txt} ${wp.dist.toFixed(0)}m`}</div>
    <div id="hint">
      WASD move, Shift drift, E enter exit, Mouse shoot, R reload, F interact, Q punch<br>
      1 pistol, 2 shotgun, 3 sniper, 4 RPG, M waypoint, V VFX, B shake, N slow, P post
    </div>
  `;
}

// Camera
function updateCamera(dt) {
  const aim = getAimPoint();
  const lookAt = new THREE.Vector3(player.pos.x, 1.55, player.pos.z);

  const back = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw)).multiplyScalar(-1);
  const camTarget = lookAt.clone()
    .addScaledVector(back, player.mode === "car" ? 11 : 8)
    .add(new THREE.Vector3(0, player.mode === "car" ? 7.2 : 6.8, 0));

  camera.position.lerp(camTarget, 1 - Math.pow(0.001, dt));

  if (player.mode === "foot") camera.lookAt(new THREE.Vector3(aim.x, 1.3, aim.z));
  else camera.lookAt(lookAt);

  if (FX.shake && shakeTime > 0) {
    const s = shakeTime * 0.55;
    camera.position.x += rand(-s,s);
    camera.position.y += rand(-s,s);
    camera.position.z += rand(-s,s);
  }
}

// Respawn
function respawnIfDead() {
  if (player.hp > 0 && playerCar.hp > 0) return;

  if (playerCar.hp <= 0) {
    const boomPos = new THREE.Vector3(player.pos.x, 0, player.pos.z);
    spawnExplosion(new THREE.Vector3(player.pos.x, 1.0, player.pos.z), 1.6);
    radialDamage(boomPos, 18, 150);

    playerCar.hp = 240;
    player.cash = Math.max(0, player.cash - 250);
    player.wanted = 0;
    player.pos.copy(WORLD.safe);
    player.yaw = 0;
    setMode("car");
    ping("Wasted");
    return;
  }

  if (player.hp <= 0) {
    const boomPos = new THREE.Vector3(player.pos.x, 0, player.pos.z);
    spawnExplosion(new THREE.Vector3(player.pos.x, 1.0, player.pos.z), 1.0);
    radialDamage(boomPos, 12, 95);

    player.hp = 100;
    player.cash = Math.max(0, player.cash - 200);
    player.wanted = 0;
    player.pos.copy(WORLD.safe);
    player.yaw = 0;
    setMode("car");
    ping("Wasted");
  }
}

// Start positions
playerCar.mesh.position.set(player.pos.x, 0, player.pos.z);
playerGuy.position.copy(player.pos);

// Main loop
let last = performance.now();
function tick(now) {
  let dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  if (FX.slowburst && slowTime > 0) dt *= 0.35;

  player.wanted = Math.max(0, player.wanted - 0.03 * dt);
  if (shakeTime > 0) shakeTime = Math.max(0, shakeTime - dt);
  if (slowTime > 0) slowTime = Math.max(0, slowTime - dt);

  updatePlayer(dt);
  updateZones(dt);
  updateMission(dt);
  updateTraffic(dt);
  updatePeds(dt);
  updateShooting(dt);
  updateBullets(dt);
  updateRockets(dt);
  updateCops(dt);
  updateParticles(dt);
  updateCarDamageVFX(dt);
  updateCamera(dt);

  if (player.mode === "car") {
    playerCar.mesh.position.set(player.pos.x, 0, player.pos.z);
    playerCar.mesh.rotation.y = player.yaw;
  } else {
    playerGuy.position.copy(player.pos);
    playerGuy.rotation.y = player.yaw;
  }

  respawnIfDead();
  updateHUD();
  drawMinimap();

  if (FX.post) composer.render();
  else renderer.render(scene, camera);

  pressedOnce.clear();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
